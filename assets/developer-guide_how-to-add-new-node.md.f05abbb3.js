import{_ as e,o as a,c as t,Q as n}from"./chunks/framework.0f749972.js";const g=JSON.parse('{"title":"How to add node to I3T","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guide/how-to-add-new-node.md","filePath":"developer-guide/how-to-add-new-node.md"}'),s={name:"developer-guide/how-to-add-new-node.md"},o=n(`<h1 id="how-to-add-node-to-i3t" tabindex="-1">How to add node to I3T <a class="header-anchor" href="#how-to-add-node-to-i3t" aria-label="Permalink to &quot;How to add node to I3T&quot;">​</a></h1><h2 id="pin-and-wire-types" tabindex="-1">pin and wire types <a class="header-anchor" href="#pin-and-wire-types" aria-label="Permalink to &quot;pin and wire types&quot;">​</a></h2><ul><li>Operations.h: defaultIoNames - strings pulse, float, vec3, vec4, matrix, and quad (no string for Matrix_MULL and SCREEN)</li><li>NodeData.h : EValueType - Pulse, Float, Vec3, Vec4, Matrix, Quat, MatrixMul, Screen, Ptr, Data is stored in the DatastoreClass in an std::variant structure, data type is in &#39;&#39;opValueType&#39;&#39;. Access is via getters &#39;&#39;getFloat&#39;&#39;, ... ,and a &#39;&#39;setValue&#39;&#39; template.</li></ul><h2 id="node-types" tabindex="-1">Node types <a class="header-anchor" href="#node-types" aria-label="Permalink to &quot;Node types&quot;">​</a></h2><p>There are three node types</p><ul><li>operator (blue box, serves as a calculator of the output from the connected inputs having no inner state ) They hav a subgroup called Constructors</li><li>sequence (envelope for matrices)</li><li>transformation (yellow box, stores the 4x4 matrix of the particular transformation)</li></ul><h2 id="how-to-add-the-transformation-node" tabindex="-1">How to add the transformation node <a class="header-anchor" href="#how-to-add-the-transformation-node" aria-label="Permalink to &quot;How to add the transformation node&quot;">​</a></h2><h3 id="adding-a-new-box-to-operations-h" tabindex="-1">Adding a new box to <code>Operations.h</code>: <a class="header-anchor" href="#adding-a-new-box-to-operations-h" aria-label="Permalink to &quot;Adding a new box to \`\`Operations.h\`\`:&quot;">​</a></h3><p>a) Operators:</p><ul><li>create a new enum in <code>enum class EOperatorType</code><ul><li>simple nodes that just compute output from given inputs</li><li>constructors create a matrix of given type (such as translation or EulerX rotation)</li></ul></li></ul><p>b) Matrices (Transformations):</p><ul><li><p>create a new enum in <code>enum class ETransformType</code></p></li><li><p>Prepare list of input and output pins into <code>static const std::vector&lt;EValueType&gt;</code> if it is not already there.</p></li><li><p>Prepare list of pin names into <code>static const std::vector&lt;std::string&gt;s</code></p></li><li><p>Add the new node into the vector of operations ()</p><ul><li>Operator: <code>{n(EOperatorType::Inversion), &quot;inversion&quot;, 1, matrixInput, 1, matrixInput},</code><ul><li>Transformation: <code>{n(EOperatorType::MakeTranslation), &quot;translate&quot;, 1, vector3Input, 1, matrixInput}, // translate</code></li><li>Use one of predefined version of &#39;&#39;Operation&#39;&#39; constructor, depending on existence of inputs, outputs, hover tag and explicit pin labels</li></ul></li></ul></li><li><p>Transform matrices have one more configuration vector &#39;&#39;ETransformType&#39;&#39;</p><ul><li>predefined pair of type and name (ETransformType and string) <ul><li>16 bit info about editable values of a locked matrix</li><li>vector of editable parameters in the middle LOD (SetValues) - pairs param_name data_type EValueType)</li></ul></li></ul></li></ul><h3 id="writing-the-operator-logic-in-core" tabindex="-1">Writing the operator logic in Core <a class="header-anchor" href="#writing-the-operator-logic-in-core" aria-label="Permalink to &quot;Writing the operator logic in Core&quot;">​</a></h3><p>Prepare the function <code>updateValues()</code> of the operator (specialization of the <code>Operator</code> template).</p><p>An example for conversion from Euler angles to Quaternion:</p><div class="language-// vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">//</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">template &lt;&gt; FORCE_INLINE void Operator&lt;EOperatorType::EulerToQuat&gt;::updateValues(int inputIndex)</span></span>
<span class="line"><span style="color:#e1e4e8;">{</span></span>
<span class="line"><span style="color:#e1e4e8;">	if (m_inputs[0].isPluggedIn() &amp;&amp; m_inputs[1].isPluggedIn() &amp;&amp; m_inputs[2].isPluggedIn())</span></span>
<span class="line"><span style="color:#e1e4e8;">	{</span></span>
<span class="line"><span style="color:#e1e4e8;"></span></span>
<span class="line"><span style="color:#e1e4e8;">		setInternalValue(</span></span>
<span class="line"><span style="color:#e1e4e8;">				glm::quat(glm::vec3(m_inputs[0].data().getFloat(), m_inputs[1].data().getFloat(),</span></span>
<span class="line"><span style="color:#e1e4e8;">														m_inputs[2].data().getFloat())));</span></span>
<span class="line"><span style="color:#e1e4e8;">	}</span></span>
<span class="line"><span style="color:#e1e4e8;">	else</span></span>
<span class="line"><span style="color:#e1e4e8;">	{</span></span>
<span class="line"><span style="color:#e1e4e8;">		setInternalValue(glm::quat());</span></span>
<span class="line"><span style="color:#e1e4e8;">	}</span></span>
<span class="line"><span style="color:#e1e4e8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">template &lt;&gt; FORCE_INLINE void Operator&lt;EOperatorType::EulerToQuat&gt;::updateValues(int inputIndex)</span></span>
<span class="line"><span style="color:#24292e;">{</span></span>
<span class="line"><span style="color:#24292e;">	if (m_inputs[0].isPluggedIn() &amp;&amp; m_inputs[1].isPluggedIn() &amp;&amp; m_inputs[2].isPluggedIn())</span></span>
<span class="line"><span style="color:#24292e;">	{</span></span>
<span class="line"><span style="color:#24292e;"></span></span>
<span class="line"><span style="color:#24292e;">		setInternalValue(</span></span>
<span class="line"><span style="color:#24292e;">				glm::quat(glm::vec3(m_inputs[0].data().getFloat(), m_inputs[1].data().getFloat(),</span></span>
<span class="line"><span style="color:#24292e;">														m_inputs[2].data().getFloat())));</span></span>
<span class="line"><span style="color:#24292e;">	}</span></span>
<span class="line"><span style="color:#24292e;">	else</span></span>
<span class="line"><span style="color:#24292e;">	{</span></span>
<span class="line"><span style="color:#24292e;">		setInternalValue(glm::quat());</span></span>
<span class="line"><span style="color:#24292e;">	}</span></span>
<span class="line"><span style="color:#24292e;">}</span></span></code></pre></div><h3 id="writing-the" tabindex="-1">Writing the <a class="header-anchor" href="#writing-the" aria-label="Permalink to &quot;Writing the&quot;">​</a></h3>`,17),l=[o];function i(p,r,d,c,u,h){return a(),t("div",null,l)}const y=e(s,[["render",i]]);export{g as __pageData,y as default};
