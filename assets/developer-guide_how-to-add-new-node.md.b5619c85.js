import{_ as a,o as s,c as e,Q as n}from"./chunks/framework.0f749972.js";const h=JSON.parse('{"title":"How to add node to I3T","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guide/how-to-add-new-node.md","filePath":"developer-guide/how-to-add-new-node.md"}'),o={name:"developer-guide/how-to-add-new-node.md"},t=n(`<h1 id="how-to-add-node-to-i3t" tabindex="-1">How to add node to I3T <a class="header-anchor" href="#how-to-add-node-to-i3t" aria-label="Permalink to &quot;How to add node to I3T&quot;">​</a></h1><p>This document describes how to add a new node to the I3T application. It is not so complex, but requires changes in several places in the code.</p><h2 id="pin-and-wire-types" tabindex="-1">Pin and wire types <a class="header-anchor" href="#pin-and-wire-types" aria-label="Permalink to &quot;Pin and wire types&quot;">​</a></h2><ul><li><code>Core/Operations.h</code>: <code>defaultIoNames</code> - strings pulse, float, vec3, vec4, matrix, and quad (no string for Matrix_MULL and SCREEN)</li><li><code>Core/NodeData.h</code>: <code>EValueType</code> - Pulse, Float, Vec3, Vec4, Matrix, Quat, MatrixMul, Screen, Ptr, Data is stored in the DatastoreClass in a <code>std::variant</code> structure, data type is in <code>opValueType</code>. Access is via getters <code>getFloat</code>, ..., and a <code>setValue</code> template.</li></ul><h2 id="node-types" tabindex="-1">Node types <a class="header-anchor" href="#node-types" aria-label="Permalink to &quot;Node types&quot;">​</a></h2><p>There are three node types:</p><ul><li>operator (blue box, serves as a calculator of the output from the connected inputs having no inner state) They have a subgroup called Constructors</li><li>sequence (envelope for matrices)</li><li>transformation (yellow box, stores the 4x4 matrix of the particular transformation)</li></ul><h2 id="step-by-step-guide" tabindex="-1">Step-by-step guide <a class="header-anchor" href="#step-by-step-guide" aria-label="Permalink to &quot;Step-by-step guide&quot;">​</a></h2><h3 id="adding-a-new-box-to-operations-h" tabindex="-1">Adding a new box to <code>Operations.h</code>: <a class="header-anchor" href="#adding-a-new-box-to-operations-h" aria-label="Permalink to &quot;Adding a new box to \`Operations.h\`:&quot;">​</a></h3><ol><li><p>Operators:</p><ul><li>create a new enum in <code>enum class EOperatorType</code><ul><li>simple nodes that just compute output from given inputs</li><li>constructors create a matrix of given type (such as translation or EulerX rotation)</li></ul></li></ul></li><li><p>Matrices (Transformations):</p><ul><li><p>create a new enum in <code>enum class ETransformType</code></p></li><li><p>Prepare list of input and output pins into <code>static const std::vector&lt;EValueType&gt;</code> if it is not already there.</p></li><li><p>Prepare list of pin names into <code>static const std::vector&lt;std::string&gt;</code></p></li><li><p>Add the new node into the vector of operations ()</p><ul><li>Operator: <code>{n(EOperatorType::Inversion), &quot;inversion&quot;, 1, matrixInput, 1, matrixInput},</code><ul><li>Transformation: <code>{n(EOperatorType::MakeTranslation), &quot;translate&quot;, 1, vector3Input, 1, matrixInput}, // translate</code></li><li>Use one of predefined version of &#39;&#39;Operation&#39;&#39; constructor, depending on existence of inputs, outputs, hover tag and explicit pin labels</li></ul></li></ul></li><li><p>Transform matrices have one more configuration vector &#39;&#39;ETransformType&#39;&#39;</p><ul><li>predefined pair of type and name (ETransformType and string) <ul><li>16 bit info about editable values of a locked matrix</li><li>vector of editable parameters in the middle LOD (SetValues) - pairs param_name data_type EValueType)</li></ul></li></ul></li></ul></li></ol><h3 id="writing-the-operator-logic-in-core" tabindex="-1">Writing the operator logic in Core <a class="header-anchor" href="#writing-the-operator-logic-in-core" aria-label="Permalink to &quot;Writing the operator logic in Core&quot;">​</a></h3><p>Prepare the function <code>updateValues()</code> of the operator (specialization of the <code>Operator</code> template).</p><p>An example for conversion from Euler angles to Quaternion:</p><div class="language-cpp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">cpp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#6A737D;">// EulerToQuat</span></span>
<span class="line"><span style="color:#F97583;">template</span><span style="color:#E1E4E8;"> &lt;&gt; FORCE_INLINE </span><span style="color:#F97583;">void</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Operator</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">EOperatorType</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">EulerToQuat</span><span style="color:#E1E4E8;">&gt;::</span><span style="color:#B392F0;">updateValues</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">int</span><span style="color:#E1E4E8;"> inputIndex)</span></span>
<span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (m_inputs[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">isPluggedIn</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> m_inputs[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">isPluggedIn</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">&amp;&amp;</span><span style="color:#E1E4E8;"> m_inputs[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">isPluggedIn</span><span style="color:#E1E4E8;">())</span></span>
<span class="line"><span style="color:#E1E4E8;">	{</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#B392F0;">glm</span><span style="color:#E1E4E8;">::vec3 </span><span style="color:#B392F0;">value</span><span style="color:#E1E4E8;">(</span></span>
<span class="line"><span style="color:#E1E4E8;">			m_inputs[</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">data</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getFloat</span><span style="color:#E1E4E8;">(), </span></span>
<span class="line"><span style="color:#E1E4E8;">			m_inputs[</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">data</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getFloat</span><span style="color:#E1E4E8;">(),</span></span>
<span class="line"><span style="color:#E1E4E8;">			m_inputs[</span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;">].</span><span style="color:#B392F0;">data</span><span style="color:#E1E4E8;">().</span><span style="color:#B392F0;">getFloat</span><span style="color:#E1E4E8;">()</span></span>
<span class="line"><span style="color:#E1E4E8;">		); </span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#B392F0;">setInternalValue</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">glm</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">quat</span><span style="color:#E1E4E8;">(value));</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">else</span></span>
<span class="line"><span style="color:#E1E4E8;">	{</span></span>
<span class="line"><span style="color:#E1E4E8;">		</span><span style="color:#B392F0;">setInternalValue</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">glm</span><span style="color:#E1E4E8;">::</span><span style="color:#B392F0;">quat</span><span style="color:#E1E4E8;">());</span></span>
<span class="line"><span style="color:#E1E4E8;">	}</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#6A737D;">// EulerToQuat</span></span>
<span class="line"><span style="color:#D73A49;">template</span><span style="color:#24292E;"> &lt;&gt; FORCE_INLINE </span><span style="color:#D73A49;">void</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Operator</span><span style="color:#24292E;">&lt;</span><span style="color:#6F42C1;">EOperatorType</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">EulerToQuat</span><span style="color:#24292E;">&gt;::</span><span style="color:#6F42C1;">updateValues</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">int</span><span style="color:#24292E;"> inputIndex)</span></span>
<span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (m_inputs[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">isPluggedIn</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> m_inputs[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">isPluggedIn</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">&amp;&amp;</span><span style="color:#24292E;"> m_inputs[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">isPluggedIn</span><span style="color:#24292E;">())</span></span>
<span class="line"><span style="color:#24292E;">	{</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6F42C1;">glm</span><span style="color:#24292E;">::vec3 </span><span style="color:#6F42C1;">value</span><span style="color:#24292E;">(</span></span>
<span class="line"><span style="color:#24292E;">			m_inputs[</span><span style="color:#005CC5;">0</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">data</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getFloat</span><span style="color:#24292E;">(), </span></span>
<span class="line"><span style="color:#24292E;">			m_inputs[</span><span style="color:#005CC5;">1</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">data</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getFloat</span><span style="color:#24292E;">(),</span></span>
<span class="line"><span style="color:#24292E;">			m_inputs[</span><span style="color:#005CC5;">2</span><span style="color:#24292E;">].</span><span style="color:#6F42C1;">data</span><span style="color:#24292E;">().</span><span style="color:#6F42C1;">getFloat</span><span style="color:#24292E;">()</span></span>
<span class="line"><span style="color:#24292E;">		); </span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6F42C1;">setInternalValue</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">glm</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">quat</span><span style="color:#24292E;">(value));</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">else</span></span>
<span class="line"><span style="color:#24292E;">	{</span></span>
<span class="line"><span style="color:#24292E;">		</span><span style="color:#6F42C1;">setInternalValue</span><span style="color:#24292E;">(</span><span style="color:#6F42C1;">glm</span><span style="color:#24292E;">::</span><span style="color:#6F42C1;">quat</span><span style="color:#24292E;">());</span></span>
<span class="line"><span style="color:#24292E;">	}</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h3 id="writing-the-transformation-logic-in-core" tabindex="-1">Writing the transformation logic in Core <a class="header-anchor" href="#writing-the-transformation-logic-in-core" aria-label="Permalink to &quot;Writing the transformation logic in Core&quot;">​</a></h3><ul><li><p>Create a new class template specialization derived from the <code>TransformationImpl&lt;ETransformType&gt;</code> class template.</p></li><li><p>Implement the <code>updateValues()</code>, <code>updateDefaultValues()</code>, and <code>reset()</code> functions.</p></li></ul><h3 id="writing-graphical-representation-in-gui" tabindex="-1">Writing graphical representation in GUI <a class="header-anchor" href="#writing-graphical-representation-in-gui" aria-label="Permalink to &quot;Writing graphical representation in GUI&quot;">​</a></h3><ol><li><p>Operators and Matrices (Transformation) - You don&#39;t need to do anything, the GUI will automatically create the node for you.</p></li><li><p>For custom node you will need to create class in <code>GUI/Elements/Nodes/</code>:</p><ul><li>Create a new class derived from <code>DIWNE::CoreNodeWithPins</code>.</li><li>Implement the constructor and the <code>centerContent()</code> method. Optionally also <code>leftContent()</code> and <code>rightContent()</code> methods to add custom pins, otherwise pins will be created automatically based on the underlying Core node.</li><li>Implement the <code>onDestroy()</code> function if needed.</li></ul></li></ol><p>Do not forget to add the new node to the &quot;Add...&quot; popup menu in <code>WorkspaceDiwne.h</code>.</p><h3 id="writing-serialization-and-deserialization" tabindex="-1">Writing serialization and deserialization <a class="header-anchor" href="#writing-serialization-and-deserialization" aria-label="Permalink to &quot;Writing serialization and deserialization&quot;">​</a></h3><p>If you created Operator or Transformation, you don&#39;t need to do anything. The serialization and deserialization is done automatically. But if you created a custom node, you need to implement custom serialization and deserialization.</p><p>Serialization is done through the <a href="./../cpp-api-reference/classes/classNodeVisitor.html"><code>NodeVisitor</code></a> class. You have to create new <code>visit</code> function for your node type there, and supply the serialization logic in derived classes - <a href="./../cpp-api-reference/classes/classSerializationVisitor.html"><code>SerializationVisitor</code></a> to serialize the node to JSON, and <code>ToScriptVisitor</code> to serialize the node to a script.</p><p>Deserialization is needed for JSON only, see the <code>State/NodeDeserializer.cpp</code> code for more details.</p>`,23),l=[t];function p(r,i,c,d,E,y){return s(),e("div",null,l)}const m=a(o,[["render",p]]);export{h as __pageData,m as default};
