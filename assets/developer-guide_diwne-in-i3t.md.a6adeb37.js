import{_ as e,o as t,c as a,Q as o}from"./chunks/framework.0f749972.js";const f=JSON.parse('{"title":"Usage of DIWNE in I3T","description":"","frontmatter":{},"headers":[],"relativePath":"developer-guide/diwne-in-i3t.md","filePath":"developer-guide/diwne-in-i3t.md"}'),n={name:"developer-guide/diwne-in-i3t.md"},i=o('<h1 id="usage-of-diwne-in-i3t" tabindex="-1">Usage of DIWNE in I3T <a class="header-anchor" href="#usage-of-diwne-in-i3t" aria-label="Permalink to &quot;Usage of DIWNE in I3T&quot;">​</a></h1><p>I3T uses the Immediate Mode Graphical User Interface method to create its user interface.</p><p>Immediate Mode Graphical User Interface, also known as IMGUI, is a type of graphical user interface often used for developing games or interactive applications. IMGUI differs from traditional graphical user interfaces in that it consists of individual elements that are always recreated on the screen with each frame, without being stored in memory.</p><p>The particular library used for the development of I3T is DearIMGUI [Cor22].</p><p>For the 2D Workspace where the use constructs s scene graph using a node editor, we developed DIWNE - Dear Imgui Wrapper Node Editor library. It is</p><p>DIWNE is a generic library. In I3T, we used its basic functions as well as some specially adapted for I3T</p><h2 id="workspacediwne-see-workspacediwne-h" tabindex="-1">WorkspaceDiwne (see WorkspaceDiwne.h) <a class="header-anchor" href="#workspacediwne-see-workspacediwne-h" aria-label="Permalink to &quot;WorkspaceDiwne (see WorkspaceDiwne.h)&quot;">​</a></h2><p>A class that represents the entire node editor space. It is inherited from DIWNE::Diwne. Implements node operations such as selectAll(), invert selection(), zoomToAll(), etc.</p><p>In I3T, there is only one instance of it - g_workspaceDiwne, because only one node editor is used.</p><p>Important attributes:</p><ul><li><p>ImDrawListSplitter m_channelSplitter: is used to draw each node into a separate ImGui channel - the nodes are then rendered in the reverse order of their appearance on the screen (the highest node is drawn first), as it is necessary to process the user action in order from the highest node to the lowest, and to block this action for lower nodes if some other node overlays the lower nodes.</p></li><li><p>m_workspaceCoreNodes: std::vector of all nodes in the node editor except those inside another node (Transformation matrix in a Sequence node). These internal nodes are stored in the node they belong to.</p></li></ul><h2 id="elements-of-the-node-editor" tabindex="-1">Elements of the node editor <a class="header-anchor" href="#elements-of-the-node-editor" aria-label="Permalink to &quot;Elements of the node editor&quot;">​</a></h2><p>The node editor view comprises several types of objects (Nodes, Pins, and Links).</p><p>For example, I3T has many specific nodes but often share common attributes and functions. To avoid code repetition, node classes are decomposed into several &quot;layers&quot; of inheritance. You can let your node use a higher-level implementation or override any function you want.</p><p>Operations such as deleting from the node editor are done in a &quot;marking way&quot; - the node marks itself as having been deleted by the user, and only in the next frame is it actually deleted by the node editor.</p><h3 id="workspace-elements-see-workspaceelements-h" tabindex="-1">Workspace elements (see WorkspaceElements.h) <a class="header-anchor" href="#workspace-elements-see-workspaceelements-h" aria-label="Permalink to &quot;Workspace elements (see WorkspaceElements.h)&quot;">​</a></h3><p>Workspace elements implement attributes common to all graphic item objects that are already drawable (they implement all necessary functions):</p><ul><li>PinKind: all pins in I3T are either input or output.</li><li>WorkspaceLevelOfDetail: each I3T node can be scaled to multiple &quot;levels of detail&quot; views (from a thumbnail to a full view)</li><li>FloatPopupMode: float values in the popup menu can represent either an angle or a value.</li><li>numberOfCharWithDecimalPoint(): this function calculates the number of characters to be drawn for a float type value with the set number of visible digits after the decimal point.</li></ul><h4 id="elements" tabindex="-1">Elements <a class="header-anchor" href="#elements" aria-label="Permalink to &quot;Elements&quot;">​</a></h4><ul><li><p>WorkspaceNode: inherits from DIWNE::Node and stores the topLabel and middleLabel as the default contents of the top and middle parts of the node.</p></li><li><p>beforeContent(): fills the background of the whole node (in ImGui, if the drawing order is essential, or the Splitter must be used)</p></li><li><p>bypassFocusForInteractionAction(): defines the area in which the node as a whole can be interacted with (internal elements such as float input are interactable by themselves independently of this). This is currently the top part of the node (the header)</p></li><li><p>WorkspacePin: inherits from DIWNE::Pin, stores the pin label and the choice of whether or not to display the label.</p></li></ul><h3 id="workspace-elements-with-core-data-see-workspaceelementswithcoredata-h" tabindex="-1">Workspace elements with core data (see WorkspaceElementsWithCoreData.h) <a class="header-anchor" href="#workspace-elements-with-core-data-see-workspaceelementswithcoredata-h" aria-label="Permalink to &quot;Workspace elements with core data (see WorkspaceElementsWithCoreData.h)&quot;">​</a></h3><p>Implementation of elements interconnected with the I3T computational core. The core has its own node representation (called nodebase), which has no graphical representation; it just stores values and provides calculations over them. Workspace elements with kernel data add graphic values and provide a rendering of the nodes themselves in the node editor workspace via DIWNE.</p><ul><li><p>WorkspaceNodeWithCoreData :</p><ul><li>store the m_nodebase pointer to its Core::Node</li><li>stores the graphical settings of a specific node (number of visible digits, level of display detail, data map with information on which values are scalable, which are frozen, and which are tied together by synergies, etc. )</li><li>fill in some basic menus (precision settings, duplication menu, etc.)</li></ul></li><li><p>WorkspaceNodeWithCoreDataWithPins: stores two std::vectors of input and output pins. Draw input/output pins based on the leftContent()/rightContent() functions</p><p>WorkspaceNodeWithCoreDataWithPins::finalize() POSSIBLE DUPLICATION OF FUNCTION WITH WorkspaceCoreInputPin.drawDiwne(): when finalizing this node, the links (stored in the input pins of this node) are added to the list (in WorkspaceDiwne) to be rendered at the end of the frame in the correct channel - for correct overlap with other nodes</p></li><li><p>WorkspaceCoreLink: inherits from DIWNE::Link, stores pointers to the two pins it links - WorkspaceCoreOutputPin and WorkspaceCoreInputPin. The link itself is stored on the input pin in I3T because, in I3T, only one connection can lead to each input pin - so this input pin is an excellent place to store the link.</p></li><li><p>WorkspaceCorePin: stores the references to Core::Pin and WorkspaceNodeWithCoreData to which it belongs.</p><ul><li><p>WorkspaceCoreInputPin: store WorkspaceCoreLink, because in I3T, only one link can lead to the input pin – therefore, the input pin is an excellent place to store the link.</p><p>processCreateAndPlugConstrutorNode(): a function that creates a new node connected to this pin (based on the type of this pin). It just sets the WorkspaceDiwneAction to CreateAndPlugTypeConstructor, and the new node is created and connected using the node editor (WorkspaceDiwne) at the end of the frame.</p></li><li><p>WorkspaceCoreOutputPin and WorkspaceCoreOutputPinWithData: sometimes, in the I3T core, the data is stored in the output pin. These classes render this data as part of the output pin. Because of the different data types (and manipulation of those types), output pins are divided into several types (WorkspaceCoreOutputPinVector3, WorkspaceCoreOutputPinVector4, etc.), and each implements the drawData() function based on its data type.</p></li></ul></li></ul><p>Static function for drawing data (drawDataVec4, drawDataVec3, drawDataMat4x4, etc.) composed of floats able to invoke popup menu (if the float is editable according to the datamap).</p><h3 id="transformation-see-workspacetransformation-h" tabindex="-1">Transformation (see WorkspaceTransformation.h) <a class="header-anchor" href="#transformation-see-workspacetransformation-h" aria-label="Permalink to &quot;Transformation (see WorkspaceTransformation.h)&quot;">​</a></h3><p>Implementation of common attributes and functions for transformations, such as information about the sequence into which the Transformation is inserted, testing whether the Transformation is valid (respects the conditions of a particular transformation), etc.</p><h4 id="transformations-see-workspacetransformation-s-h" tabindex="-1">Transformations (see WorkspaceTransformation_s.h) <a class="header-anchor" href="#transformations-see-workspacetransformation-s-h" aria-label="Permalink to &quot;Transformations (see WorkspaceTransformation_s.h)&quot;">​</a></h4><p>Implementing the specific type behavior (Core::ETransformType). The implementation is in the template style.</p><h3 id="sequence-see-workspacesequence-h" tabindex="-1">Sequence (see WorkspaceSequence.h) <a class="header-anchor" href="#sequence-see-workspacesequence-h" aria-label="Permalink to &quot;Sequence (see WorkspaceSequence.h)&quot;">​</a></h3><p>Provides functions for inserting and removing a transformation to/from a sequence and moving a transformation between a sequence and the node editor (workspace). When moving a transformation into a sequence, select the transformation to be removed from the workspace and add it to the sequence and vice versa.</p><h3 id="other-node-types-worspacecamera-h-workspacecycle-h" tabindex="-1">Other node types (WorspaceCamera.h, WorkspaceCycle.h, ...) <a class="header-anchor" href="#other-node-types-worspacecamera-h-workspacecycle-h" aria-label="Permalink to &quot;Other node types (WorspaceCamera.h, WorkspaceCycle.h, ...)&quot;">​</a></h3><p>Inherit from WorkspaceNodeWithCoreDataWithPins (or WorkspaceNodeWithCoreData) and implement/override functions that are specific to this node. Hopefully, nothing tricky is happening here, so a brief inspection of the code should be enough to figure it out.</p>',32),r=[i];function s(h,l,c,p,d,u){return t(),a("div",null,r)}const w=e(n,[["render",s]]);export{f as __pageData,w as default};
